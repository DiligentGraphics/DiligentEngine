"#ifndef _GLTF_PBR_PRECOMPUTE_COMMON_FXH_\n"
"#define _GLTF_PBR_PRECOMPUTE_COMMON_FXH_\n"
"\n"
"#include \"PBR_Common.fxh\"\n"
"\n"
"#ifndef PI\n"
"#   define PI 3.1415926536\n"
"#endif\n"
"\n"
"float2 Hammersley2D(uint i, uint N) \n"
"{\n"
"    // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\n"
"    uint bits = (i << 16u) | (i >> 16u);\n"
"    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n"
"    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n"
"    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n"
"    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n"
"    float rdi = float(bits) * 2.3283064365386963e-10;\n"
"    return float2(float(i) / float(N), rdi);\n"
"}\n"
"\n"
"// Based on http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_slides.pdf\n"
"float3 ImportanceSampleGGX( float2 Xi, float Roughness, float3 N )\n"
"{\n"
"    float a        = Roughness * Roughness;\n"
"    float Phi      = 2.0 * PI * Xi.x;\n"
"    float CosTheta = sqrt( (1.0 - Xi.y) / ( 1.0 + (a*a - 1.0) * Xi.y ) );\n"
"    float SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\n"
"    float3 H;\n"
"    H.x = SinTheta * cos( Phi );\n"
"    H.y = SinTheta * sin( Phi );\n"
"    H.z = CosTheta;\n"
"    float3 UpVector = abs(N.z) < 0.999 ? float3(0.0, 0.0, 1.0) : float3(1.0, 0.0, 0.0);\n"
"    float3 TangentX = normalize( cross( UpVector, N ) );\n"
"    float3 TangentY = cross( N, TangentX );\n"
"    // Tangent to world space\n"
"    return TangentX * H.x + TangentY * H.y + N * H.z;\n"
"}\n"
"\n"
"#endif // _GLTF_PBR_PRECOMPUTE_COMMON_FXH_\n"
